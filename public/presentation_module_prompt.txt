Project: Dynamic Presentation Generator
Phase 2: Frontend Implementation (Vue.js)
Document Version: 1.0
Date: September 3, 2025
Status: Approved

1. Objective
This document details the step-by-step plan for building the frontend interface for the Dynamic Presentation Generator within our existing Vue.js-based CRM. The goal is to create an intuitive and efficient user experience for our team to create, manage, and share dynamic presentations by consuming the backend API.

The project will be broken down into logical phases, starting with core setup and progressively building out the user-facing components.

2. Phase 1: Core Setup & Services
This foundational phase involves setting up the necessary tools and services that all other components will rely on.

Task 2.1: Project Scaffolding & API Client

Integrate a new module or set of routes within the existing CRM for the presentation generator.

Create a dedicated API service client (e.g., using Axios). This client will be configured with the base URL for the API (/api/v1/) and will handle all HTTP requests and error handling in a centralized location.

Task 2.2: State Management Setup

Integrate a state management library (e.g., Pinia is recommended for modern Vue 3).

Define a presentation store. This store will hold the state of the presentation currently being edited, including the main details, all slides, and all content blocks. This is crucial for managing the complex data structure of the editor.

The initial state structure should mirror the JSON response from the GET /presentations/{id} endpoint.

3. Phase 2: Presentation Management Dashboard
This phase focuses on building the main dashboard where users can view and manage all presentations.

Task 3.1: Component: PresentationList.vue

This component will be the main entry point.

On load, it will call the GET /presentations endpoint via the API client.

It will display the presentations in a table with columns for Title, Associated Client/Lead, Type, and Date Created.

Each row will have an "Edit" button that navigates to the main editor view for that presentation, and a "Delete" button that calls the DELETE /presentations/{id} endpoint.

A "Create New Presentation" button will trigger the PresentationForm component.

Task 3.2: Component: PresentationForm.vue

This component will be used for both creating and editing a presentation's top-level details. It can be a modal or a separate page.

It will contain a form with fields for:

title (text input)

type (dropdown: 'Audit Report', 'Proposal', etc.)

A searchable dropdown to select the presentable (Client or Lead). This will require an endpoint to search your client/lead models.

On submit, it will call either POST /presentations or PUT /presentations/{id}.

4. Phase 3: The Main Editor View
This is the core workspace for building a presentation. It will be a single-page interface composed of several child components.

Task 4.1: View: EditorView.vue

This is the parent container component for the entire editor.

When this view is loaded (e.g., at a route like /presentations/{id}/edit), it will call the GET /presentations/{id} endpoint and populate the Pinia store with the full presentation data.

It will have a two-column layout: a sidebar for slide management and a main content area for editing the selected slide.

Task 4.2: Component: SlideManager.vue

This component will render in the sidebar of the EditorView.

It will display a list of all slides from the presentation data in the store.

Crucially, it must implement drag-and-drop functionality (e.g., using a library like VueDraggable). When the user reorders the slides, this component will call the POST /slides/reorder endpoint with the new sequence of slide IDs.

It will include buttons to "Add New Slide" and "Delete Selected Slide."

5. Phase 4: The Slide Content Editor
This is the most interactive and complex part of the application, where users build the content of each slide.

Task 5.1: Component: SlideEditor.vue

This component occupies the main content area of the EditorView.

It displays the content for the currently selected slide (as chosen in the SlideManager).

It will feature a dropdown to change the template_name for the current slide.

It will display a list of ContentBlockForm components for each block on the slide.

It must also have drag-and-drop functionality for reordering content blocks within the slide, which will call the POST /content_blocks/reorder endpoint.

Task 5.2: Component: ContentBlockForm.vue

This is a dynamic component that renders the correct form fields based on the block_type prop it receives.

Example logic:

If block_type is 'heading', it shows a text input for text and a dropdown for level.

If block_type is 'image', it shows a file uploader and an input for alt_text.

If block_type is 'feature_card', it shows inputs for icon, title, and description.

Any changes in these forms will update the data in the Pinia store, which will trigger a live preview update. Changes should be auto-saved to the backend (PUT /content_blocks/{id}) after a short delay (debouncing).

Task 5.3: Component: SlidePreview.vue

This component will render a live, non-editable preview of the slide.

It will reactively update whenever the data in the Pinia store changes.

It will use the template_name to apply the correct layout and will loop through the content_blocks to render the content, closely mimicking the final public view.

6. Phase 5: Public View & Final Integration
Task 6.1: Component: PublicPresenter.vue

This component will be responsible for rendering the final, client-facing presentation. It will live on a public-facing route (e.g., /view/{share_token}).

It will fetch the presentation data and dynamically render the slides and content blocks.

The HTML structure, CSS, and interactive JavaScript from the original .html files will be adapted into this component's template and logic.

Task 6.2: Final CRM Integration

In the PresentationList.vue component, add a "Share" button.

This button will copy the public URL (containing the share_token) to the user's clipboard, making it easy for our team to share the final presentation with clients and leads.
